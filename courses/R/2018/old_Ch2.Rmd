---
title: '**Introduction to Statistical Modelling in `R`**'
author: "Dae-Jin Lee < dlee@bcamath.org >"
date: "BCAM-UPV/EHU Courses 2018-2019"
output:
  slidy_presentation:
    fig_caption: yes
    font_adjustment: 5
    highlight: monochrome
    smart: no
    theme: cerulean
  beamer_presentation:
    colortheme: seahorse
    fonttheme: professionalfonts
  ioslides_presentation:
    highlight: monochrome
---


***********

# Basic plotting and data analysis in `R`

*  Scatterplot

```{r,fig.align='center'}
data("mtcars")
attach(mtcars) #?attach
plot(wt, mpg, main="Scatterplot Example",
   xlab="Car Weight", ylab="Miles Per Gallon", pch=19) 
```

* Basic Scatterplot Matrix

```{r,fig.align='center'}
pairs(~mpg+disp+drat+wt,data=mtcars,
   main="Simple Scatterplot Matrix")
```

* Barplot

```{r,fig.pos='center',fig.align='center'}
tab <- table(mtcars[,c("cyl")])
barplot(tab)
```

* Piechart

```{r,fig.align='center'}
pie(tab)
```


**Exercises:**

1. The data.frame `VADeaths` contains the death rates per 1000 in Virginia (US) in 1940. The death rates are measured per 1000 population per year. They are cross-classified by age group (rows) and population group (columns). 

```{r}
data(VADeaths)
VADeaths
```

* Compute the mean for each age group. 

      + **Result:**

```{r,echo=FALSE}
apply(VADeaths,1,mean)
```

* Compute the mean for each population group. 

      + **Result:** 
      
```{r,echo=FALSE}
apply(VADeaths,2,mean)
```

2. The  `data.frame` `rainforest` contains several variables from different `species`

```{r, results='hide'}
library(DAAG)
rainforest
?rainforest
names(rainforest)
```

  * Create a table of counts for each `species` and make a graphic with the results. 
  
      + **Result:**
      
```{r,echo=FALSE}
table(rainforest$species)
barplot(table(rainforest$species))
```

3. The `Acmena` `data.frame` is created from  `rainforest` using the function `subset`. 

  * Plot the relationship between the wood biomass (`wood`) and the diameter of the breast height (`dbh`). Use also a logarithm scale.

```{r}
Acmena <- subset(rainforest, species == "Acmena smithii")
```

 
```{r,echo=FALSE, fig.width=10,fig.height=8, fig.align='center'}
par(mfrow=c(1,2))
plot(wood~dbh,data=Acmena,pch=19, main="plot of dbh vs wood")
plot(log(wood)~log(dbh),data=Acmena,pch=19,main="log transformation")
```


  * Compute a histogram of variable `dbh` using function `hist`

```{r,echo=FALSE,fig.align='center'}
hist(Acmena$dbh,col="grey")
```

4. Create a vector of the positive odd integers less than 100 and remove the values greater than 60 and less than 80.

    * **Result:** 
    
```{r,echo=FALSE}
  x <- seq(1,100,by=2)
  x[x>60 & x<80]
```


* [Solutions here](http://idaejin.github.io/bcam-courses/rbasics/rbasics_sol.R)


***********

# Scatterplots

```{r, message= FALSE, warning=FALSE}
library(MASS)
data("mammals")
?mammals
head(mammals)
attach(mammals)
species <- row.names(mammals)
x <- body
y <- brain
```

```{r,fig.align='center'}
library(calibrate)
# scatterplot
plot(x,y, xlab = "body weight in kgr", ylab = "brain weight in gr", 
     main="Body vs Brain weight \n for 62 Species of Land Mammals",xlim=c(0,8500))
textxy(x,y,labs=species,col = "blue",cex=0.85) 
```

Identify a point in the scatterplot
```{r, eval=FALSE}
identify(x,y,species)
```

Plot in the log scale
```{r,fig.align='center'}
plot(log(x),log(y), xlab = "log body weight in kgr", ylab = "log brain weight in gr", 
     main="log Body vs log Brain weight \n for 62 Species of Land Mammals")
textxy(log(x),log(y),labs=species,col = "blue",cex=0.85) 
```

Identify a point in the log scale scatterplot
```{r, eval=FALSE}
identify(log(x),log(y),species)
```


**Multiple Data Sets on One Plot**

One common task is to plot multiple data sets on the same plot. In many situations, the way to do this is to create the initial plot and then add additional information to the plot. For example, to plot bivariate data the `plot` command is used to initialise and create the plot. The `points` command can then be used to add additional datasets to the plot.


```{r,fig.align='center'}
set.seed(1234)
 x <- rnorm(10,sd=5,mean=20)
 y <- 2.5*x - 1.0 + rnorm(10,sd=9,mean=0)
 cor(x,y)
 plot(x,y,xlab="Independent",ylab="Dependent",main="Random plot")
 x1 <- runif(8,15,25)
 y1 <- 2.5*x1 - 1.0 + runif(8,-6,6)
 points(x1,y1,col=2)
```

with legend and $(x_2,y_2)$ points:
```{r}
set.seed(1234)
x2 <- runif(8,15,25)
y2 <- 2.5*x2 - 1.0 + runif(8,-6,6)
 plot(x,y,xlab="Independent",ylab="Dependent",main="Random plot")
 points(x1,y1,col=2,pch=3)
 points(x2,y2,col=4,pch=5)
 legend("topleft",c("Original","one","two"),col=c(1,2,4),pch=c(1,3,5))
```

<!-- **Errors bars:** -->

<!-- ```{r,fig.width=8,fig.height=6} -->
<!-- plot(x,y,xlab="Independent",ylab="Dependent",main="Random plot",ylim=c(20,90)) -->
<!-- xHigh <- x -->
<!-- yHigh <- y + abs(rnorm(10,sd=3.5)) -->
<!-- xLow <- x -->
<!-- yLow <- y - abs(rnorm(10,sd=3.1)) -->
<!-- arrows(xHigh,yHigh,xLow,yLow,col=2,angle=90,length=0.1,code=3) -->
<!-- ``` -->

<!-- ```{r,fig.width=8,fig.height=6} -->
<!-- plot(1:20,0*(1:20),pch=1:20,cex=2) -->
<!-- ``` -->

**Multiple Graphs on One Image:**

```{r,fig.align='center'}
set.seed(1234)
 par(mfrow=c(2,3))
 boxplot(rnorm(100),main="first plot")
 boxplot(rgamma(100,2),main="second plot", horizontal=TRUE,col="bisque")
 plot(rnorm(100),xlab="third plot",
      ylab="y-label",main="x-label")
 hist(rnorm(100),main="fourth plot",col="lightgrey")
 hist(rexp(100),main="fifth plot",col="blue")
 plot(rnorm(100),rexp(100),main="sixth plot")
```

**Pairwise relationships**

```{r}
uData <- rnorm(20)
vData <- rnorm(20,mean=5)
wData <- uData + 2*vData + rnorm(20,sd=0.5)
xData <- -2*uData+rnorm(20,sd=0.1)
yData <-  3*vData+rnorm(20,sd=2.5)
d <- data.frame(u=uData,v=vData,w=wData,x=xData,y=yData)
pairs(d)
```

**Plotting correlations**

The function `corrplot` in the `library(corrplot)` visualizes a correlation matrix calculate with function `cor`

```{r, fig.width=8,fig.align='center'}
library(corrplot)
M <- cor(d)
corrplot(M, method="circle",type="upper")
```

**Plotting surfaces: `image`, `contour` and `persp` plots**

```{r, fig.width=10, fig.height=10,fig.align='center'}
x <- seq(0,2*pi,by=pi/50)
y <- x
xg <- (x*0+1) %*% t(y)
yg <- (x) %*% t(y*0+1)
f <- sin(xg*yg)

par(mfrow=c(2,2))
image(x,y,f)
contour(x,y,f)
contour(x,y,f,nlevels=4)
image(x,y,f,col=grey.colors(100))
contour(x,y,f,nlevels=4,add=TRUE,col="red")
```


Similarly, one can use `persp` plot
```{r,fig.align='center'}
persp(x,y,f,theta=-30,phi=55,col="lightgrey",shade=.01)
```


Or plot images

```{r,message=FALSE,warning=FALSE,fig.width=10,fig.height=10,fig.align='center'}
library(fields)
data(lennon)
image(lennon,col=grey(seq(0,1,l=256)))
```

# Tables and Cross-classification

```{r}
library(MASS)
data(quine)
?quine
attach(quine)
table(Sex)
table(Sex,Age)

# or xtabs
xtabs(~Sex+Age,data=quine)
xtabs(~Sex+Age+Eth,data=quine)
```

**Calculations of cross-classifications**

```{r}
tapply(Days,Age,mean)
```

```{r}
tapply(Days,list(Sex,Age),mean)
```


```{r}
tapply(Days,list(Sex,Age),function(x) sqrt(var(x)/length(x)))
```


# Qualitative data

A data sample is called qualitative, also known as categorical if its values belong to a collection of known defined non-overlapping classes. 

Let us consider some artificial data consisting of the `treatment` and `improvement` of patients with rheumatoid arthritis.

```{r}
treatment <- factor(rep(c(1, 2), c(43, 41)), levels = c(1, 2),
                    labels = c("placebo", "treated"))
improved <- factor(rep(c(1, 2, 3, 1, 2, 3), c(29, 7, 7, 13, 7, 21)),
                   levels = c(1, 2, 3),
                   labels = c("none", "some", "marked"))
```
We can compute a cross-classification table
```{r}
xtabs(~treatment+improved)
```

Graphically,
```{r,fig.align='center'}
spineplot(improved ~ treatment)
```


The `R` dataset `UCBAdmissions` contains aggregated data on applicants to graduate school at Berkeley for the six largest departments in 1973 classified by admission and sex.


```{r}
data("UCBAdmissions")
?UCBAdmissions
apply(UCBAdmissions, c(2,1), sum)
prop.table(apply(UCBAdmissions, c(2,1), sum))
ftable(UCBAdmissions)
```

The same but with a more readable format can be obtained using `ftable`
```{r}
ftable(round(prop.table(UCBAdmissions), 3),
       row.vars="Dept", col.vars = c("Gender", "Admit"))
```

More interesting are the proportions admitted for each `Gender` by `Dept` combination (dimensions 2 and 3 of the array).  Notice that `male` and `female` admission rates are about the same in all departments, except "A", where female admission rates are higher.

```{r}
# prop.table(UCBAdmissions, c(2,3))
ftable(round(prop.table(UCBAdmissions, c(2,3)), 2),
       row.vars="Dept", col.vars = c("Gender", "Admit"))
```


```{r}
## Data aggregated over departments
apply(UCBAdmissions, c(1, 2), sum)
```


Applications and admissions by department at UC Berkeley can be viewed graphically.

```{r,fig.align='center'}
spineplot(margin.table(UCBAdmissions, c(3, 2)),
           main = "Applications at UCB")
spineplot(margin.table(UCBAdmissions, c(3, 1)),
           main = "Admissions at UCB")

```


This data set is frequently used for illustrating *Simpson's paradox*. At issue is whether the data show evidence of sex bias in admission practices. There were 2691 male applicants, of whom 1198 (44.5%) were admitted, compared with 1835 female applicants of whom 557 (30.4%) were admitted. Men were much more successful in admissions than women. [Wikipedia: Gender Bias UC Berkeley](https://en.wikipedia.org/wiki/Simpson%27s_paradox#UC_Berkeley_gender_bias). See animation at [link](http://vudlab.com/simpsons/) 
 

# Quantitative data

Quantitative data, also known as continuous data, consists of numeric data that support arithmetic operations. 

```{r}
head(faithful)
```

It consists of a collection of observations of the Old Faithful geyser in the USA Yellowstone National Park. 
&nbsp;

There are two observation variables in the dataset. The first one, called `eruptions`, is the duration of the geyser eruptions. The second one, called `waiting`, is the length of waiting period until the next eruption. It turns out there is a correlation between the two variables.

```{r,fig.align='center'}
plot(faithful)
```

# Frequency distribution of quantitative data

The frequency distribution of a data variable is a summary of the data occurrence in a collection of non-overlapping categories. 

Let us find the frequency distribution of the eruption duration in `faithful` data set.

```{r}
duration <- faithful$eruptions
range(duration)
```

&nbsp;

Now we create the range of non-overlapping sub-intervals by defining a sequence of equal distance break points. 

If we round the endpoints of the interval [1.6, 5.1] to the closest half-integers, we come up with the interval [1.5, 5.5]. Hence we set the breakpoints to be the half-integer sequence { 1.5, 2.0, 2.5, ... }. 

```{r}
breaks <- seq(1.5,5.5,by=0.5)
breaks
```

&nbsp;

Classify the eruption durations according to the half-unit-length sub-intervals with `cut`. As the intervals are to be closed on the left, and open on the right, we set the right argument to `FALSE`. 

```{r}
duration.cut = cut(duration, breaks, right=FALSE) 
```
Compute the frequency of eruptions in each sub-interval with the table function. 

```{r}
duration.freq = table(duration.cut) 
duration.freq
```

`hist` function does all the computaions to find the frequency distribution:

```{r}
freq <- hist(duration)
freq

freq <- hist(duration,breaks = breaks)

hist(duration,50)
```


**Density estimation** builds an estimate of some underlying probability density function
using an observed data sample.

```{r,fig.align='center'}
library(graphics)
d <- density(faithful$eruptions)
d
plot(d)
```

&nbsp;
Two dimension histogram:

```{r,message=FALSE,warning=FALSE,fig.align='center'}
library(gplots)
h2 <- hist2d(faithful, nbins=30,xlab="Duration in minutes",ylab="Waiting")
h2
names(h2)
```

&nbsp;

Relative frequencies 

```{r}
duration.relfreq <- duration.freq / nrow(faithful) 
tab <- cbind(duration.freq, duration.relfreq) 
apply(tab,2,sum)
```

&nbsp;

Cumulative frequency distribution

```{r}
cumsum(duration.freq)
cumsum(duration.relfreq)
```

<!-- We can plot the cumulative relative frequency graph of a quantitative variable, which is a curve graphically showing the cumulative relative frequency distribution.  -->
<!-- The e.c.d.f. (empirical cumulative distribution function) $F_n$ is a step function with jumps $i/n$ at observation values, where $i$ is the number of tied observations at that value. Missing values are ignored. -->

<!-- For observations $x = (x_1,x_2, ... x_n)$, $F_n$ is the fraction of observations less or equal to $t$, i.e., -->

<!-- $$ -->
<!-- F_n(t) = \#{x_i <= t}/n = 1/n \sum_{i=1}^n I(x_i \leq t). -->
<!-- $$ -->
<!-- where $I$ is an indication function. -->




<!-- ```{r} -->
<!-- plot(ecdf(duration)) -->
<!-- ``` -->

**Bivariante Density estimation:**
```{r, fig.align='center'}
data("faithful")
attach(faithful)
Dens2d<-kde2d(eruptions,waiting)
image(Dens2d,xlab="eruptions",ylab="waiting")
contour(Dens2d,add=TRUE,col="black",lwd=2,nlevels=5)
detach("faithful")
```

**Perspective plot:**

```{r,fig.align='center'}
persp(Dens2d,phi=30,theta=20,d=5,xlab="eruptions",ylab="waiting",zlab="",shade=.2,col="lightblue",expand=.85,ticktype = "detailed")
```

# Advanced plotting `ggplot2`

```{r,eval=FALSE}
library(ggplot2)
```

**Why `ggplot2`?**


Advantages of ggplot2

   - consistent underlying `grammar of graphics' (Wilkinson, 2005)

   - plot specification at a high level of abstraction

   - very flexible

   - theme system for polishing plot appearance

   - mature and complete graphics system

   - many users, active mailing list


*Example:* `Housing data` [download](http://idaejin.github.io/bcam-courses/R/2017/data/dataSets.zip)

```{r}
housing <- read.csv("data/landdata-states.csv")
head(housing[1:5])

# change column names
names(housing)[names(housing) == "Land.Share..Pct."] <- "Land.Share.Pct"
head(housing, 10)
```


## `ggplot2` VS Base for simple graphs

Base graphics histogram are:

```{r,fig.align='center'}
hist(housing$Home.Value)
```

```{r,message=FALSE,warning=FALSE,fig.align='center'}
library(ggplot2)
ggplot(housing, aes(x = Home.Value)) +
  geom_histogram()
```

Another simple graph

```{r,fig.align='center'}
plot(Home.Value ~ Date,
     data=subset(housing, State == "MA"))
points(Home.Value ~ Date, col="red",
       data=subset(housing, State == "TX"))
legend(1975, 400000,
       c("MA", "TX"), title="State",
       col=c("black", "red"),
       pch=c(1, 1))
```

`ggplot` version, colored scatter plot example:

```{r,fig.align='center'}
ggplot(subset(housing, State %in% c("MA", "TX")),
       aes(x=Date,
           y=Home.Value,
           color=State))+
  geom_point()
```


**Geometric Objects And Aesthetics**

    *Aesthetic Mapping:*

 In `ggplot` land /aesthetic/ means "something you can see". Examples include:
    
  - position (i.e., on the x and y axes)
    
  - color ("outside" color)

  - fill ("inside" color)
  
  - shape (of points)

  - linetype
     
  - size

Each type of geom accepts only a subset of all aesthetics--refer to the geom help pages to see what mappings each geom accepts. Aesthetic
mappings are set with the `aes()` function.

### Geometric Objects (`geom`)

Geometric objects are the actual marks we put on a plot. 

Examples include:

  - points (`geom_point`, for scatter plots, dot plots, etc)
  
  - lines (`geom_line`, for time series, trend lines, etc)
  
  - boxplot (`geom_boxplot`, for, boxplots)

  - A plot must have at least one geom; there is no upper limit. You can add a `geom` to a plot using the `+` operator



**More** at [http://had.co.nz/ggplot2/](http://had.co.nz/ggplot2/)


**Some examples:**

```{r,message=FALSE,warning=FALSE,fig.align='center'}
library(ggplot2)
?qplot
qplot(displ, hwy, data = mpg, colour = factor(cyl))
qplot(mpg, wt, data = mtcars)
qplot(mpg, wt, data = mtcars, colour = cyl)
qplot(mpg, wt, data = mtcars, size = cyl)
qplot(mpg, wt, data = mtcars, size = cyl, alpha = I(0.7))
qplot(mpg, wt, data = mtcars, facets = vs ~ am)

qplot(displ, hwy, data=mpg, facets = . ~ year) + geom_smooth()

p <- ggplot(mtcars)
p <- p + aes(wt, hp)
p + geom_point(aes(colour = factor(cyl)))

p <- ggplot(mtcars, aes(mpg, wt))
p + geom_point(colour = "darkblue")
```

Get data from the internet

```{r, eval = FALSE}
filepath <- "http://idaejin.github.io/courses/R/2018/data/ggplot2_data.txt"

myData<-read.table(file=url(filepath),header=TRUE,sep="\t")

str(myData)

qplot(data=myData,x=BM,main="Histogram of BodyMass")

qplot(data=myData,x=BM,y=var1,log="xy",color=Tribe)
```


# Maps



## Example: Malignant Melanoma in the USA

Fisher and Belle (1993) report mortality rates due to malignant melanoma of the skin for white males during the period 1950-1969, for each state on the US mainland. 


```{r}
data("USmelanoma",package="HSAUR2")
head(USmelanoma)
```

A data consists of 48 observations on the following 5 variables.

  * `mortality`: number of white males died due to malignant melanoma 1950-1969 per one million inhabitants.

  * `latitude`: latitude of the geographic centre of the state.

  * `longitude`: longitude of the geographic centre of each state.

  * `ocean`: a binary variable indicating contiguity to an ocean at levels `no` or `yes`.


## Plotting mortality rates

```{r}
xr <- range(USmelanoma$mortality) * c(0.9, 1.1)
```

Let us plot mortality rates in 

```{r,fig.align='center'}
#layout(matrix(1:2, nrow = 2))
boxplot(USmelanoma$mortality, ylim = xr, horizontal = TRUE,xlab = "Mortality")
hist(USmelanoma$mortality, xlim = xr, xlab = "", main = "",axes = FALSE, ylab = "")
axis(1)
```

Malignant melanoma mortality rates by contiguity to an ocean

```{r,fig.align='center'}
plot(mortality ~ ocean, data = USmelanoma, 
     xlab = "Contiguity to an ocean", ylab = "Mortality")
```

Histograms can often be misleading for displaying distributions because of their dependence on the number of classes chosen. An alternative is to formally estimate the density function of a variable and then plot the resulting estimate.

The estimated densities of malignant melanoma mortality rates by contiguity to an ocean looks like this:

```{r,fig.width=12,fig.height=10,fig.align='center'}
dyes<- with(USmelanoma, density(mortality[ocean == "yes"]))
dno <- with(USmelanoma, density(mortality[ocean == "no"]))
plot(dyes, lty = 1, xlim = xr, main = "", ylim = c(0, 0.018))
lines(dno, lty = 2)
legend("topright", lty = 1:2, legend = c("Coastal State","Land State"), bty = "n")
```


Now we might move on to look at how mortality rates are related to the geographic location of a state as represented by the latitude and longitude of the centre of the state. 

```{r,fig.align='center'}
layout(matrix(1:2, ncol = 2))
plot(mortality ~ -longitude, data = USmelanoma)
plot(mortality ~ latitude, data = USmelanoma)
```

## Mapping mortality rates

The data contains the longitude and latitude of the centroids 

```{r,fig.align='center',message=FALSE,warning=FALSE}
plot(-USmelanoma$longitude,USmelanoma$latitude,
     asp=1.5,cex=.3,pch=19,col="blue")
```


```{r,fig.align='center',message=FALSE,warning=FALSE}
library("sp")
library("maps")
library("maptools")
library("RColorBrewer")
map("state")
points(-USmelanoma$longitude,USmelanoma$latitude,asp=1.5,cex=.3,pch=19,col="blue")
```

```{r,fig.align='center',message=FALSE,warning=FALSE}
#qplot(-USmelanoma$longitude,USmelanoma$latitude,colour=USmelanoma$mortality,asp=1.5)+scale_color_gradient(low="blue", high="red")+geom_point()

#Create a function to generate a continuous color palette
rbPal <- colorRampPalette(c('blue','grey','red'))
#This adds a column of color values
# based on the y values
USmelanoma$Col <- (rbPal(10)[as.numeric(cut(USmelanoma$mortality,breaks = 10))])
map("state",xlim=c(-135,-65))
points(-USmelanoma$longitude,USmelanoma$latitude,col=USmelanoma$Col,asp=1.5,pch=19,cex=1.2)
legend("topleft",title="Decile",legend=quantile(USmelanoma$mortality,
        seq(0.1,1,l=10)),col =rbPal(10),pch=15,cex=1.,box.col = NA)
```

```{r,fig.width=12,fig.height=10,fig.align='center',message=FALSE,warning=FALSE}
states <- map("state", plot = FALSE, fill = TRUE)
IDs <- sapply(strsplit(states$names, ":"), function(x) x[1])
rownames(USmelanoma) <- tolower(rownames(USmelanoma))

us1 <- map2SpatialPolygons(states, IDs=IDs,proj4string = CRS("+proj=longlat +datum=WGS84"))
us2 <- SpatialPolygonsDataFrame(us1, USmelanoma)

col <- colorRampPalette(c('blue', 'gray80','red'))

spplot(us2, "mortality", col.regions = col(200),
       par.settings = list(axis.line = list(col =  'transparent')),
       main="Map of the US showing malignant melanoma mortality rates")
```

Packages for Spatial Regression / Geostatistics / Spatial Point Pattern methods 

* `sp`, `maptools`, `spatstat`
* `maps`

```{r,eval=FALSE}
install.packages(c("sp","maptools","spatstat","maps"))
```

```{r, message=FALSE,warning=FALSE}
library(maps)
```

Basic syntax

```{r, message=FALSE,warning=FALSE}
map(database = "world",regions=".")
```

Databases are available for US, France, Italy and New Zealand. For other countries, you need to import a database with the corresponding map.

```{r, message=FALSE,warning=FALSE}
map(database = "usa")
map("state")
```

`ggmap` offers plotting capabilities like `ggplot2`

```{r,message=FALSE,warning=FALSE}
library(ggmap)
geocode("Bilbao, Spain")
```



<!-- http://www.stat.ucla.edu/~rosario/boot08/ -->

<!-- This section describes how to customize your graphs. It also covers more statistically sophisticated graphs. -->


<!-- ```{r} -->
<!-- #PAGE 12 -->
<!-- #Bivariate plot of textbook prices. -->
<!-- texts <- read.csv("http://www.stat.ucla.edu/~rosario/boot08/data/book-shopping.csv",header=TRUE) -->
<!-- plot(texts[,5],texts[,7],main="Bivariate Analysis of\n Textbook Prices",xlab="Amazon Sales Price",ylab="Borders Sales Price",pch='*',xaxt="n",yaxt="n",cex.lab=0.75,bg="grey") -->
<!-- mtext("Fall 2008",3,font=3) -->
<!-- axis(1,at=seq(0,200,25),paste("$",seq(0,200,25)),cex.axis=0.75,col="grey") -->
<!-- axis(2,at=seq(0,200,25),paste("$",seq(0,200,25)),cex.axis=0.75,col="grey") -->
<!-- axis(c(3:4),col="grey",tick=FALSE,labels=FALSE) -->
<!-- box("plot",col="grey") -->
<!-- ``` -->

```{r,eval=FALSE,echo=FALSE,message=FALSE}
library(knitr)
purl("Ch2.Rmd",output="Ch2.R")
```


