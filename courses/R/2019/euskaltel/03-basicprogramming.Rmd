
# Introducción a la programación básica con `R`

## Condicionales

**Comparaciones**

  - equal: `==`
  
```{r}
  "hola" == "hola"
  "hola" == "Hola"
   1 == 2-1
```

  
  
  - not equal: `!=`
  

```{r}
    a <- c(1,2,4,5)
    b <- c(1,2,3,5) 
    a == b
    a != b
```
  
  - mayor/menor que: `>` `<`

```{r}
set.seed(1)
a <- rnorm(10)
b <- rnorm(10)
a<b
```  

  - mayor/menor que o igual: `>=` `<=`
  
```{r}
set.seed(2)
a <- rnorm(10)
b <- rnorm(10)
a >= b
```


  - `which`
```{r}
set.seed(3)
which(a>b)

LETTERS
which(LETTERS=="R")
```
 
  - `which.min` o `which.max`
```{r}
set.seed(4)
a <- rnorm(10)
a
which.min(a)
which.max(a)
```

  - `is.na`
```{r}
 a[2] <- NA
is.na(a)
which(is.na(a))
```

## Operadores Lógicos

  - and: `&`

```{r}
z = 1:6
which(2 < z & z > 3)
```

  - or: `|`
  
```{r}
z = 1:6
(z > 2) & (z < 5)
which((z > 2) & (z < 5))
```

  - not: `!`

```{r}
x <- c(TRUE,FALSE,0,6)
y <- c(FALSE,TRUE,FALSE,TRUE)

!x
```
<!--
Operators `&` and `|` perform element-wise operation producing result having length of the longer operand. But `&&` and `||` examines only the first element of the operands resulting into a single 
length logical vector. Zero is considered `FALSE` and non-zero numbers are taken as `TRUE`. 
-->

**Ejemplo:**


  - `&&` vs `&`

```{r}
x&y
x&&y
```

 - `||` vs `|`
 
 
```{r}
x||y
x|y
```


## `if` statements

`if(cond1=true) { cmd1 } else { cmd2 }`

```{r}
if(1==0) {
    print(1)
} else {
    print(2)
}
```

## `ifelse` 

`ifelse(test, true_value, false_value)`

```{r}
x <- 1:10 # Creates sample data
ifelse(x<5 | x>8, x, 0)
```


## `while` 


## Loops o Bucles

Los más empleados en `R` son `for`, `while` y `apply`. Los menos habituales `repeat`.  La función `break` sirve para salir de un bucle loop.

### `for`

<!--For loops are controlled by a looping vector. In every iteration of the loop one value in the looping vector is assigned to a variable that can be used in the statements of the body of the loop. Usually, the number of loop iterations is defined by the number of values stored in the looping vector and they are processed in the same order as they are stored in the looping vector.
-->


Sintaxis

```
for(variable in sequence) {
    statements
}
```


```{r}
for (j in 1:5)
{
  print(j^2)
}
```

Repetir el bucle guardando los resultados en un vector `x`. 

```{r}
n = 5
x = NULL  # creates a NULL object
for (j in 1:n)
{
  x[j] = j^2
}
x
```

Generamos el lanzamiento de un dado

```{r}
nsides = 6
ntrials = 1000
trials = NULL
for (j in 1:ntrials)
{
  trials[j] = sample(1:nsides,1)  # We get one sample at a time
}
mean(trials^2)
```

**Ejemplo:** 

```{r,eval=FALSE}
x <- 1:10
z <- NULL
for(i in seq(along=x)) {
    if (x[i]<5) {
        z <- c(z,x[i]-1) 
    } else {
        stop("values need to be <5")
    }
}
## Error: values need to be <5
z
## [1] 0 1 2 3
```



## `while`

Similar al bucle `for`, pero las iteraciones están controladas por una condición.

```{r}
z <- 0
while(z < 5) {
    z <- z + 2
    print(z) 
}
```

<!--
## Famila de funciones `apply` 



**Syntax:**

```
apply(X, MARGIN, FUN, ARGs)
```

`X`: `array`, `matrix` or `data.frame`; `MARGIN`: 1 for rows, 2 for columns, `c(1,2)` for both; `FUN`: one or more functions; `ARGs`: possible arguments for function.

```{r, eval=FALSE}
## Example for applying predefined mean function
apply(mtcars[,1:3], 1, mean)

## With custom function
x <- 1:10
test <- function(x) { # Defines some custom function
    if(x < 5) {
        x-1
    } else {
        x / x
    }
} 

apply(as.matrix(x), 1, test) 

## Same as above but with a single line of code
apply(as.matrix(x), 1, function(x) { if (x<5) { x-1 } else { x/x } })
```

**For Ragged Arrays: `tapply`**

Apply a function to each cell of a ragged array, that is to each (non-empty) group of values given by a unique combination of the levels of certain factors.

```{r,eval=TRUE}
## Computes mean values of vector agregates defined by factor
tapply(as.vector(mtcars$mpg), factor(mtcars$cyl), mean)

## The aggregate function provides related utilities
aggregate(mtcars[,c(1,3,4)], list(mtcars$cyl), mean)
```


**For Vectors and Lists: `lapply` and `sapply`**

Both apply a function to vector or list objects. The function `lapply` returns a list, while `sapply` attempts to return the simplest data object, such as `vector` or `matrix` instead of `list`. 

*Syntax*

```
lapply(X,FUN)
sapply(X,FUN)
```

```{r, echo=TRUE}
## Creates a sample list
mylist <- as.list(mtcars[,c(1,4,6)])
mylist
```

Compute sum of each list component and return result as list

```{r}
lapply(mylist, sum)
```

Compute sum of each list component and return result as vector

```{r}
sapply(mylist, sum)
```

## Other Loops

**Repeat Loop**

*Syntax*

`repeat` statements

Loop is repeated until a break is specified. This means there needs to be a second statement to test whether or not to break from the loop.

*Example:*
```
z <- 0
repeat {
    z <- z + 1
    print(z)
    if(z > 100) break()
}
```

## Improving Speed Performance of Loops

Looping over very large data sets can become slow in `R`. However, this limitation can be overcome by eliminating certain operations in loops or avoiding loops over the data intensive dimension in an object altogether. The latter can be achieved by performing mainly vector-to-vector or matrix-to-matrix computations which run often over 100 times faster than the corresponding `for()` or `apply()` loops in `R`. For this purpose, one can make use of the existing speed-optimized R functions (e.g.: `rowSums`, `rowMeans`, `table`, `tabulate`) or one can design custom functions that avoid expensive `R` loops by using vector- or matrix-based approaches. Alternatively, one can write programs that will perform all time consuming computations on the C-level.


1. Speed comparison of `for` loops with an append versus and inject step

```{r,eval=FALSE}
N <- 1e3
myMA <- matrix(rnorm(N), N, 10, dimnames=list(1:N, paste("C", 1:10, sep="")))
results <- NULL
system.time(for(i in seq(along=myMA[,1])) 
            results <- c(results, mean(myMA[i,])))

results <- numeric(length(myMA[,1]))
system.time(for(i in seq(along=myMA[,1])) 
            results[i] <- mean(myMA[i,]))
```
The inject approach is 20-50 times faster than the append version.

2. Speed comparison of `apply` loop versus `rowMeans` for computing the mean for each row in a large matrix:

```{r,eval=FALSE}
system.time(myMAmean <- apply(myMA, 1, mean))
system.time(myMAmean <- rowMeans(myMA))
```

The `rowMeans` approach is over 200 times faster than the `apply` loop.


-->

<!-- http://manuals.bioinformatics.ucr.edu/home/programming-in-r#TOC-Control-Structures -->
