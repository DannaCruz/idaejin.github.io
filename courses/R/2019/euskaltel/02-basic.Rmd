# Análisis de datos básico en `R` {#basic}

## Gráficos sencillos


*  Scatterplot

```{r}
attach(mtcars)
plot(wt, mpg, main="Scatterplot Example",
   xlab="Car Weight ", ylab="Miles Per Gallon ", pch=19) 
```

* Matriz scatterplot

```{r}
pairs(~mpg+disp+drat+wt,data=mtcars,
   main="Simple Scatterplot Matrix")
```

* Barplot o diagrama de barras

```{r,fig.pos='center'}
tab <- table(mtcars[,c("cyl")])
barplot(tab)
```

* Piechart o diagrama de tarta

```{r,fig.align='center'}
pie(tab)
```



**Ejercicio:**

1. El `data.frame` `VADeaths` contiene las tasas de mortalidad por cada 1000 habitantes en Virginia (EEUU) en 1940

  + Las tasas de mortalidad se miden cada 1000 habitantes por año. Se encuentran clasificadas por grupo de edad (filas) y grupo de población (columnas). Los grupos de edad son: 50-54, 55-59, 60-64, 65-69, 70-74 y los grupos de población: `Rural/Male`, `Rural/Female`, `Urban/Male` and `Urban/Female`.

```{r}
data(VADeaths)
VADeaths
```

* Calcula la media para cada grupo de edad. 

      + **Result:**

```{r,echo=FALSE}
apply(VADeaths,1,mean)
```

* Calcula la media para cada grupo de población. 

      + **Resultado:** 
      
```{r,echo=FALSE}
apply(VADeaths,2,mean)
```

2. El  `data.frame` `rainforest` contiene diferentes variables de `species`

```{r, results='hide'}
library(DAAG)
rainforest
?rainforest
names(rainforest)
```

  * Crear una tabla de conteos para cada `species` y realiza un gráfico descriptivo. 
  
      + **Resultado:**
      
```{r,echo=FALSE}
table(rainforest$species)
barplot(table(rainforest$species))
```

3. El `data.frame` `Acmena` est?  creado a partir de `rainforest` mediante la función `subset`. 

  * Realiza un gráfico que relacione la biomasa de la madera (`wood`) y el di?metro a la altura del pecho (`dbh`). Utiliza tambi?n la escala logarítmica.

```{r}
Acmena <- subset(rainforest, species == "Acmena smithii")
```

 
```{r,echo=FALSE, fig.width=10,fig.height=8}
par(mfrow=c(1,2))
plot(wood~dbh,data=Acmena,pch=19, main="plot of dbh vs wood")
plot(log(wood)~log(dbh),data=Acmena,pch=19,main="log transformation")
```


  * Calcula un histograma de la variable `dbh` mediante la función `hist`

```{r,echo=FALSE}
hist(Acmena$dbh,col="grey")
```

4. Crea un vector de n?meros enteros positivos impares the longitud 100 y  calcula los valores entre 60 y 80.

    * **Result:** 
    
```{r,echo=FALSE}
  x <- seq(1,100,by=2)
  x[x>60 & x<80]
```


* [Soluciones aquí](http://idaejin.github.io/bcam-courses/rbasics/rbasics_sol.R)


***********

## Scatterplots

```{r, message= FALSE, warning=FALSE}
library(MASS)
data("mammals")
?mammals
head(mammals)
attach(mammals)
species <- row.names(mammals)
x <- body
y <- brain
```

```{r,fig.align='center'}
library(calibrate)
# scatterplot
plot(x,y, xlab = "body weight in kgr", ylab = "brain weight in gr", 
     main="Body vs Brain weight \n for 62 Species of Land Mammals",xlim=c(0,8500))
textxy(x,y,labs=species,col = "blue",cex=0.85) 
```

Identificar un punto en el scatterplot

```{r, eval=FALSE}
identify(x,y,species)
```

En escala logarítmica

```{r,fig.align='center'}
plot(log(x),log(y), xlab = "log body weight in kgr", ylab = "log brain weight in gr", 
     main="log Body vs log Brain weight \n for 62 Species of Land Mammals")
textxy(log(x),log(y),labs=species,col = "blue",cex=0.85) 
```

Identificar un punto en la escala logarítmica
```{r, eval=FALSE}
identify(log(x),log(y),species)
```

## más opciones gráficas

**Varios conjuntos de datos en un sólo gráfico**

Una vez realizado un `plot`, el comando `points` permite aadir nuevas observaciones.


```{r}
set.seed(1234)
 x <- rnorm(10,sd=5,mean=20)
 y <- 2.5*x - 1.0 + rnorm(10,sd=9,mean=0)
 cor(x,y)
 plot(x,y,xlab="Independent",ylab="Dependent",main="Random plot")
 x1 <- runif(8,15,25)
 y1 <- 2.5*x1 - 1.0 + runif(8,-6,6)
 points(x1,y1,col=2)
```

con la leyenda
```{r}
set.seed(1234)
x2 <- runif(8,15,25)
y2 <- 2.5*x2 - 1.0 + runif(8,-6,6)
 plot(x,y,xlab="Independent",ylab="Dependent",main="Random plot")
 points(x1,y1,col=2,pch=3)
 points(x2,y2,col=4,pch=5)
 legend("topleft",c("Original","one","two"),col=c(1,2,4),pch=c(1,3,5))
```

<!-- **Errors bars:** -->

<!-- ```{r,fig.width=8,fig.height=6} -->
<!-- plot(x,y,xlab="Independent",ylab="Dependent",main="Random plot",ylim=c(20,90)) -->
<!-- xHigh <- x -->
<!-- yHigh <- y + abs(rnorm(10,sd=3.5)) -->
<!-- xLow <- x -->
<!-- yLow <- y - abs(rnorm(10,sd=3.1)) -->
<!-- arrows(xHigh,yHigh,xLow,yLow,col=2,angle=90,length=0.1,code=3) -->
<!-- ``` -->

<!-- ```{r,fig.width=8,fig.height=6} -->
<!-- plot(1:20,0*(1:20),pch=1:20,cex=2) -->
<!-- ``` -->

**Varios gráficos en un sola imagen**

```{r}
set.seed(1234)
 par(mfrow=c(2,3))
 boxplot(rnorm(100),main="first plot")
 boxplot(rgamma(100,2),main="second plot", horizontal=TRUE,col="bisque")
 plot(rnorm(100),xlab="third plot",
      ylab="y-label",main="x-label")
 hist(rnorm(100),main="fourth plot",col="lightgrey")
 hist(rexp(100),main="fifth plot",col="blue")
 plot(rnorm(100),rexp(100),main="sixth plot")
```

**Relaciones entre variables**

```{r}
uData <- rnorm(20)
vData <- rnorm(20,mean=5)
wData <- uData + 2*vData + rnorm(20,sd=0.5)
xData <- -2*uData+rnorm(20,sd=0.1)
yData <-  3*vData+rnorm(20,sd=2.5)
d <- data.frame(u=uData,v=vData,w=wData,x=xData,y=yData)
pairs(d)
```

**Gráfico de correlaciones**

La función `corrplot` de la librer?a `corrplot` permite visualizar una matriz de correlaciones calculada mediante la función `cor`

```{r, fig.width=8}
library(corrplot)
M <- cor(d)
corrplot(M, method="circle",type="upper")
```

**Gráficos de superficies: `image`, `contour` y `persp`**

```{r, fig.width=10, fig.height=10}
x <- seq(0,2*pi,by=pi/50)
y <- x
xg <- (x*0+1) %*% t(y)
yg <- (x) %*% t(y*0+1)
f <- sin(xg*yg)

par(mfrow=c(2,2))
image(x,y,f)
contour(x,y,f)
contour(x,y,f,nlevels=4)
image(x,y,f,col=grey.colors(100))
contour(x,y,f,nlevels=4,add=TRUE,col="red")
```


Podemos utilizar la función `persp`

```{r,fig.width=10,fig.height=10,fig.align='center'}
persp(x,y,f,theta=-30,phi=55,col="lightgrey",shade=.01)
```


o representar im?genes

```{r,message=FALSE,warning=FALSE,fig.width=10,fig.height=10}
library(fields)
data(lennon)
image(lennon,col=grey(seq(0,1,l=256)))
```

## Tablas de clasificación cruzada o de contigencia

```{r}
library(MASS)
data(quine)
head(quine)
attach(quine)
table(Sex)
table(Sex,Age)

# or xtabs
xtabs(~Sex+Age,data=quine)
xtabs(~Sex+Age+Eth,data=quine)
```

## cálculos sobre tablas de contigencia

```{r}
tapply(Days,Age,mean)
```

```{r}
tapply(Days,list(Sex,Age),mean)
```


```{r}
tapply(Days,list(Sex,Age),function(x) sqrt(var(x)/length(x)))
```


## Datos cualitativos

Supongamos unos datos cualquiera de las variables `treatment` y `improvement` de pacientes a una enfermedad determinada.

```{r}
treatment <- factor(rep(c(1, 2), c(43, 41)), levels = c(1, 2),
                    labels = c("placebo", "treated"))
improved <- factor(rep(c(1, 2, 3, 1, 2, 3), c(29, 7, 7, 13, 7, 21)),
                   levels = c(1, 2, 3),
                   labels = c("none", "some", "marked"))
```
Tabla de contigencia
```{r}
xtabs(~treatment+improved)
```

De manera gráfica,
```{r}
spineplot(improved ~ treatment)
```


El conjunto de datos de `R`, `UCBAdmissions`contiene los datos agregadps de los solicitantes a universidad de Berkeley a los seis departamentos más grandes en 1973 clasificados por sexo y admisión.


```{r}
data("UCBAdmissions")
?UCBAdmissions
apply(UCBAdmissions, c(2,1), sum)
prop.table(apply(UCBAdmissions, c(2,1), sum))
ftable(UCBAdmissions)
```

Con `ftable` podemos presentar la información con mayor claridad
```{r}
ftable(round(prop.table(UCBAdmissions), 3),
       row.vars="Dept", col.vars = c("Gender", "Admit"))
```

Resulta más intereseante mostrar la información por género `Gender` y `Dept` combinados (dimensiones 2 y 3 del array). Nótese que las tasas de admisión por `male` y `female` son más o menos similares en todos los departamentos, excepto en "A", donde las tasas de las mujeres es mayor.

```{r}
# prop.table(UCBAdmissions, c(2,3))
ftable(round(prop.table(UCBAdmissions, c(2,3)), 2),
       row.vars="Dept", col.vars = c("Gender", "Admit"))
```


```{r}
## Data aggregated over departments
apply(UCBAdmissions, c(1, 2), sum)
````

gr?ficamente

```{r}
spineplot(margin.table(UCBAdmissions, c(3, 2)),
           main = "Applications at UCB")
spineplot(margin.table(UCBAdmissions, c(3, 1)),
           main = "Admissions at UCB")

```

Estos datos ilustran la denominada *paradoja de Simpson*. Este hecho ha sido analizado como un posible caso de discriminación por sexo en las tasas de admisión en Berkeley. De los 2691 hombres que solicitaron se admitidos, 1198 (44.5%) fueron admitidos, comparado con las 1835 mujeres de las cuales tan s?lo 557 (30.4%) fueron admitidas. Se podr?a por tanto concluir que los hombres tienes tasas de admisión mayores que las mujeres. [Wikipedia: Gender Bias UC Berkeley](https://en.wikipedia.org/wiki/Simpson%27s_paradox#UC_Berkeley_gender_bias). See animation at [link](http://vudlab.com/simpsons/) 
 


## Datos cuantitativos



```{r}
head(faithful)
```


Consideremos los datos del geyse Old Faithful en el parque nacional de Yellowstone, EEUU. 

```{r}
plot(faithful)
```

### Distribuciones de frecuencias 

Vamos a utilizar el conjunto de datos `faithful`, para ilustrar el concepto de distribuci?n de frecuencias que consistir? en crear una series de categor?as o intervalos, en los que contaremos el n?mero de observaciones en cada categor?a.

```{r}
duration <- faithful$eruptions
range(duration)
```

Crearemos los sub-intervalos entre `[1.6, 5.1]` y la secuencia `{ 1.5, 2.0, 2.5, ... }`. 

```{r}
breaks <- seq(1.5,5.5,by=0.5)
breaks
```

La función `cut` nos permite divider el rango en los intervalos que especifiquemos, con el argumento `right=FALSE`, consideramos el intervalo cerrado por la derecha. 

```{r}
duration.cut = cut(duration, breaks, right=FALSE) 
```

Con `table` generamos las frecuencias 

```{r}
duration.freq = table(duration.cut) 
duration.freq
```

Con `hist` podemos realizarlo de manera autom?tica: 

```{r}
freq <- hist(duration)
freq

freq <- hist(duration,breaks = breaks)

hist(duration,50)
```


**Estimación de densidad** construye una estimación dada una distribucion de probabilidad para una muestra dada.

```{r}
require(graphics)
d <- density(faithful$eruptions)
d
plot(d)
```

En dos dimensiones:

```{r,message=FALSE,warning=FALSE}
library(gplots)
h2 <- hist2d(faithful, nbins=30,xlab="Duration in minutes",ylab="Waiting")
h2
names(h2)
```

Frecuencias relativas

```{r}
duration.relfreq <- duration.freq / nrow(faithful) 
tab <- cbind(duration.freq, duration.relfreq) 
apply(tab,2,sum)
```

Distribución de frecuencias acumuladas:

```{r}
cumsum(duration.freq)
cumsum(duration.relfreq)
```

<!-- We can plot the cumulative relative frequency graph of a quantitative variable, which is a curve graphically showing the cumulative relative frequency distribution.  -->
<!-- The e.c.d.f. (empirical cumulative distribution function) $F_n$ is a step function with jumps $i/n$ at observation values, where $i$ is the number of tied observations at that value. Missing values are ignored. -->

<!-- For observations $x = (x_1,x_2, ... x_n)$, $F_n$ is the fraction of observations less or equal to $t$, i.e., -->

<!-- $$ -->
<!-- F_n(t) = \#{x_i <= t}/n = 1/n \sum_{i=1}^n I(x_i \leq t). -->
<!-- $$ -->
<!-- where $I$ is an indication function. -->




<!-- ```{r} -->
<!-- plot(ecdf(duration)) -->
<!-- ``` -->

**Estimación bivariante tipo kernel**
```{r}
data("faithful")
attach(faithful)
Dens2d<-kde2d(eruptions,waiting)
image(Dens2d,xlab="eruptions",ylab="waiting")
contour(Dens2d,add=TRUE,col="black",lwd=2,nlevels=5)
detach("faithful")
```

**Gráficos `persp`**

```{r}
persp(Dens2d,phi=30,theta=20,d=5,xlab="eruptions",ylab="waiting",zlab="",shade=.2,col="lightblue",expand=.85,ticktype = "detailed")
```

